/**
 * 输入一个链表，输出该链表中倒数第k个结点。
 * 从1开始计数，即链表尾节点是倒数第1个节点。
 * 例如：一个链表有六个节点，值依次为1、2、3、4、5、6.则倒数第三个节点值为4。
 * 
 * function ListNode(x) {
 *   this.val = x;
 *   this.next = null;
 * }
 * 
 * 解题思路：
 * 假设整个链表有n个节点，那么倒数第k个节点就是从头节点开始的第 n-k+1 个节点。
 * 为了实现只遍历链表一次，可以定义两个指针。
 * 1）第一个指针从链表头结点开始向前走 k-1 步，第二个指针保持不动；
 * 2）从第k步开始，两个指针一起向前走，距离始终保持在 k-1；
 * 3）当第一个指针走到尾节点时，第二个指针正好指向导数第k个节点。
 * 
 * 注意代码的鲁棒性：
 * 1）输入为空指针
 * 2）链表节点总数小于k
 * 3）k等于0
 * 
 * 相关题目：
 * 求链表的中间节点。如果链表中节点总数为奇数，返回中间节点；若为偶数，返回中间两个节点的任意一个。
 * 同样可以定义两个指针，一个快指针，一个慢指针。
 * 两个指针同时从链表的头结点出发，快指针一次走两步，慢指针一次走一步。
 * 当快指针走到尾节点时，慢指针正好走到链表的中间。
 * 
 * 链表问题常见解题思路：
 * 当使用一个指针遍历聊表不能解决问题的时候，可以尝试用两个指针来遍历链表。
 * 可以让其中一个走的快一些，或者先走几步。
 */
function findKthToTail(head, k) {
  if (head == null || k <= 0) {
    return null;
  }

  let p1 = head;
  let p2 = head;

  while (--k) {
    if (!p1.next) {
      return null;
    }
    p1 = p1.next;
  }

  while (p1.next) {
    p1 = p1.next;
    p2 = p2.next;
  }

  return p2.val;
}
